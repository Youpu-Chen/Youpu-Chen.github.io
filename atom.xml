<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Youpu-Chen.github.io/</id>
    <title>陈有朴</title>
    <updated>2022-11-23T01:56:51.115Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Youpu-Chen.github.io/"/>
    <link rel="self" href="https://Youpu-Chen.github.io/atom.xml"/>
    <subtitle>有谱</subtitle>
    <logo>https://Youpu-Chen.github.io/images/avatar.png</logo>
    <icon>https://Youpu-Chen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 陈有朴</rights>
    <entry>
        <title type="html"><![CDATA[「基因组」基因组组装之前要做的：Genome Survey]]></title>
        <id>https://Youpu-Chen.github.io/post/genomesurvey/</id>
        <link href="https://Youpu-Chen.github.io/post/genomesurvey/">
        </link>
        <updated>2022-10-16T07:36:39.000Z</updated>
        <content type="html"><![CDATA[<p>基因组组装之前，有一些问题还是需要注意的，</p>
<ul>
<li>genome size是多少？</li>
<li>评估得到的genome heterozygosity是多少？</li>
<li>重复序列的占比是多少？</li>
</ul>
<p>可以系统性地称为genome survey，这是一个非常简单的分析，但是其实有一些问题是值得注意的</p>
<p>Genome Survey一般基于Illumina short reads进行分析，因为二代测序便宜，先测出来试试水，</p>
<p>再判断三代的数据量，这应该算是一个非常经济实惠的做法。</p>
<h1 id="分析流程">分析流程</h1>
<p>1）fastp、Trimmomatic等软件挑一个过滤低质量序列</p>
<p>2）Jellyfish 2.3.0、KMC3</p>
<p>我个人其实比较喜欢KMC，因为可以直接读取<code>.gz</code>文件（绝对不是因为之前KMC作者帮助我愉快地解决了一个Bug），但是解决jellyfish脚本的过程中也让我对Shell Kernel有了一个更深刻的理解。</p>
<p>3）Genome Scope 2.0、GCE等软件，挑一个进行genome size、heterozygosity等指标的估计</p>
<p>我个人比较熟悉的还是Genome Scope 2.0，因为这个软件可以用于<a href="https://github.com/Youpu-Chen/Pipeline-for-Polyploid-Analysis">判断auto-tetraploid和allo-tetraploid</a>，</p>
<p>同时作者Michael C. Schatz的实验室还开发了FALCON~</p>
<h1 id="fastp">fastp</h1>
<pre><code class="language-shell">vim fastp.sh
sh fastp.sh 2&gt;fastp.err.log &amp;
</code></pre>
<p>Shell script:</p>
<pre><code class="language-shell">#!/bin/bash
# Preset
dir=&lt;specicy_path_of_your_rawdata&gt;
echo &quot;The raw dataset is placed at $dir&quot;
echo &quot;Now running Quality control&quot;
thread=24    # set 24 threads
quality=20   # set quality cutoff to 20 based on Phred33 
# 
fastp -w $thread -q $quality -i $dir/sample1.fq.gz -I $dir/sample2.fq.gz -o ./sample_clean_1.fq.gz -O ./sample_clean_2.fq.gz
</code></pre>
<h1 id="jellyfish-count-k-mer">Jellyfish: count k-mer</h1>
<pre><code class="language-shell">vim jellyfish.sh
chmod 777 jellyfish.sh  # key step, otherwise the script below will report syntax error
./jellyfish.sh 2&gt;jellyfish.err.log &amp;
</code></pre>
<p>“哼男人，嘴上说着喜欢KMC，但是却用Jellyfish”，</p>
<p>Shell script:</p>
<pre><code class="language-shell"># Preset
dir=&lt;specicy_path_of_your_cleandata&gt;
echo &quot;The clean dataset is placed at $dir&quot;
echo &quot;Now running Jellyfish Kmercount&quot;

# 17mer
echo &quot;Now running 17mer counting&quot;
content1=&quot;jellyfish count -C -m 17 -o ./sample.17mer.jf -s 10G -t 24 &lt;(pigz -dc $dir/sample_clean_1.fq.gz) &lt;(pigz -dc $dir/sample_clean_2.fq.gz)&quot;
echo &quot;The command is $content1&quot;

jellyfish count \
-C \
-m 17 \
&lt;( pigz -dc $dir/sample_clean_1.fq.gz ) &lt;( pigz -dc $dir/sample_clean_2.fq.gz ) \
-o ./sample.17mer.jf -s 10G -t 24


# 21mer: recommanded by author
echo &quot;Now running 21mer counting&quot;
content2=&quot;jellyfish count -C -m 21 -o ./sample.21mer.jf -s 10G -t 24 &lt;(pigz -dc $dir/sample_clean_1.fq.gz) &lt;(pigz -dc $dir/sample_clean_2.fq.gz)&quot;
echo &quot;The command is $content2&quot;

jellyfish count \
-C \
-m 21 \
&lt;( pigz -dc $dir/sample_clean_1.fq.gz ) &lt;( pigz -dc $dir/sample_clean_2.fq.gz ) \
-o ./sample.21mer.jf -s 10G -t 24
</code></pre>
<p>注意点：为什么要用<code>chmod 777</code>？<br>
答：未经777赋予可执行权限的脚本，仍为shell脚本，需要指定<code>bash</code>或者<code>sh</code>来运行程序，即不可从<code>jellyfish</code>直接开始运行程序，</p>
<p>就好比原本的运行方式为<code>bash &lt;script_name&gt;.sh</code>，现在要修改成为<code>./&lt;script_name&gt;.sh</code>的运行方式，不然就会出现syntax errror</p>
<h1 id="jellyfish-k-mer-spectrum-generation">Jellyfish: k-mer spectrum generation</h1>
<pre><code class="language-shell">jellyfish histo -t 24 -l 1 -h 500000 sample.17mer.jf &gt; sample.17mer.histo &amp;
jellyfish histo -t 24 -l 1 -h 500000 sample.21mer.jf &gt; sample.21mer.histo &amp;
</code></pre>
<p>注意点：<code>upper limitation</code>的修改。</p>
<p>Genome Scope 2.0的分析需要将k-mer spectrum的upper limit设置得高一些，不然后续genome size估计塌缩比例会特别大。</p>
<h1 id="genome-scope-20-smudeplot">Genome Scope 2.0 + Smudeplot</h1>
<p>1）The estimation of genome size, heterozygosity, etc.</p>
<pre><code class="language-shell">vim genomescope.sh
chmod 777 genomescope.sh
./genomescope.sh 2&gt;genomescope.err.log &amp;
</code></pre>
<p>Shell script:</p>
<pre><code class="language-shell">script=&lt;path_to_your_genomescope_repo&gt;/genomescope.R
dir=&lt;where_kmerspectrum_deposited&gt;
Rscript $script -i &lt;input_histo&gt; -o ./ -n &lt;outputname&gt; -p &lt;ploidy_level&gt; -k &lt;kmer_used&gt;
</code></pre>
<p>2）Kmer-pair plot</p>
<p>这部分官网其实给出了比较好的流程，我就只是简单概括走一下，</p>
<pre><code class="language-shell">dir=&lt;specify_your_kmercount_database&gt;
L=$(smudgeplot.py cutoff &lt;histo_from_kmc&gt; L)
U=$(smudgeplot.py cutoff &lt;histo_from_kmc&gt; U)
echo $L $U # these need to be sane values
# conda activate genomesurvey
kmc_tools transform $dir/&lt;kmc_db&gt; -ci&quot;$L&quot; -cx&quot;$U&quot; dump -s smudgeplot_kmc_db/&lt;kmc_db&gt;.kmc_L&quot;$L&quot;_U&quot;$U&quot;.dump
# conda activate smudgeplot
smudgeplot.py hetkmers -o smudgeplot_kmercounts/&lt;kmc_db&gt;.kmc_L&quot;$L&quot;_U&quot;$U&quot; &lt; smudgeplot_kmc_db/&lt;kmc_db&gt;.kmc_L&quot;$L&quot;_U&quot;$U&quot;.dump

# Plot
smudgeplot.py plot &lt;kmc_db&gt;._L&quot;$L&quot;_U&quot;$U&quot;_coverages.tsv
</code></pre>
<p>结果示意图如下，</p>
<figure data-type="image" tabindex="1"><img src="https://Youpu-Chen.github.io//post-images/1665905861119.png" alt="" loading="lazy"></figure>
<p><strong>基因组大小估计需要注意的点</strong>，</p>
<p>0）三代数据不适合用于Kmer分析，因为测序错误率高了很多，会对分析结果产生非常大的影响，</p>
<p>但是HiFi reads以及canu和falcon产生的corrected reads可以很好的适用于Genome Scope分析</p>
<p>1）<code>jellyfish histo</code>输出时指定的maximum kmer-freq，会极大地影响到genome size的估计，因此需要根据自己的数据进行调整，一般100000再往上也可</p>
<p>2）<code>genonomescope.R</code>的<code>-p</code>以及<code>--kcov</code>的设置，都会影响到genome size的估计</p>
<p>比如在genomescope2.0 model下，如果<strong>在输入数据和模型都已经定下来的基础上，将<code>--kcov</code>设置为原本的一倍，则genome size的大小估计会减半</strong>（此处感兴趣的，我建议还是自行搜索下基于kmer计算genome size的公式）</p>
<p>3）结果中的<code>transformed_linear_plot</code>和<code>linear_plot</code>有什么区别？</p>
<p>前者的<code>observed</code>曲线经过了一个转换，越往后的peak其峰值越大，即在原始的kmer freq上乘了一个n（n代表第n个peak），</p>
<p>后者的<code>observed</code>曲线为实际观测到的一个数值，没有经过上述转换</p>
<p>transformed linear：</p>
<figure data-type="image" tabindex="2"><img src="https://Youpu-Chen.github.io//post-images/1665905871689.png" alt="" loading="lazy"></figure>
<p>linear plot：</p>
<figure data-type="image" tabindex="3"><img src="https://Youpu-Chen.github.io//post-images/1665905877897.png" alt="" loading="lazy"></figure>
<p>4）Genome Scope 2.0分析时，如果将过多的kmer判定为了<code>error</code>，最终的genome size就会小了特别多（基于genome size的计算公式）</p>
<h1 id="背后的原理">背后的原理</h1>
<p>首先需要明确的一个点是：Genome Scope 是基于diploid进行编写的。</p>
<p>关于二倍体物种的基因组大小估计，如何理解。我想要举一个非常简单的例子来理解：</p>
<p>给个用kmer将genome给“划分”开的示意，</p>
<pre><code class="language-shell">				kmer:   ---A--
                		 --A---
                		  -A----
                		   A-----
				genome: ---A-----------------------------------------------
</code></pre>
<ul>
<li>
<p>假设当前的基因组非常纯合（-&gt; homozygous, not -&gt; heterozygous），kmer会在某一个频数上呈现一个峰值，</p>
</li>
<li>
<p>但是如果当前的基因组杂合度上升了，也就是我们一般在文献中看到的heterozygosity，kmer在另一个频数较小的区域，也会呈现一个峰值，也就是Genome Survey中提到的杂合峰</p>
<p>就比如下图中的T，是A对应的allele。该种情况的存在，会导致kmer出现另一种情况，从而降低了纯合峰的高度，比如下图的例子就表示了对应位置kmer的频数，从4降低到了2，</p>
<p>即可以将diploid的kmer topology理解为：aa，ab</p>
</li>
</ul>
<pre><code class="language-shell">				kmer:   ---A--
                		 --A---
				genome: ---A-----------------------------------------------
				           T
				        ---T--
				         --T---
</code></pre>
<p>所以，为了满足polyploid的产生，Genome Scope 2.0被开发 —— 基于负二项分布的Kmer模型，用于估计genome size、heterozygosity等。</p>
<p>三倍体的kmer topolygy：aaa（3种haplotype均一致），aab（有1种haplotype和另外2个haplotype存在区别），abc（3种haplotype各不相同）</p>
<p>四倍体的kmer topology：aaaa，aaab，aabb，abcd</p>
<h1 id="参考资料">参考资料</h1>
<p>[1] https://github.com/schatzlab/genomescope/issues/32</p>
<p>[2] https://github.com/schatzlab/genomescope/issues/43</p>
<p>[3] https://github.com/schatzlab/genomescope/issues/48</p>
<p>[4] https://github.com/schatzlab/genomescope</p>
<p>[5] https://github.com/KamilSJaron/smudgeplot</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「一文搞定序列比对算法」Global以及Local Alignment序列比对算法的实现]]></title>
        <id>https://Youpu-Chen.github.io/post/globalandlocal_alignment/</id>
        <link href="https://Youpu-Chen.github.io/post/globalandlocal_alignment/">
        </link>
        <updated>2022-10-08T06:15:10.000Z</updated>
        <content type="html"><![CDATA[<p>序列比对是什么以及序列比对主要的作用是什么，本篇博客就一笔带过，因为不是主要分享内容。</p>
<p>序列比对，此处引申为pairwise alignment会更加恰当一些，用于比较2条序列之间的相似程度，推断它们之间的相似程度，进而探索对应功能以及系统发育关系。</p>
<p>接下来大体分为2个部分，1）全局比对，2）局部比对</p>
<p>首先要明确一个概念：<strong>序列比对想要达到的目的是什么？</strong></p>
<p>引一张图来说明序列比对的目的以及全局比对、局部比对之间的区别，</p>
<p>总的来说，也就是全局比对和局部比对想要达到的目的是不一样的，</p>
<ul>
<li>全局比对想要得到的是2条序列最佳的匹配结果（e.g. 最多的match数量、最高的比对得分、最高的identity），局部比对想要得到的是2条序列中<strong>最佳匹配片段</strong>（注意：最佳的匹配结果需要建立在相对较少的序列修改上）</li>
<li>全局比对更适用于evolution关系上更加靠近的（e.g. 粳稻和籼稻），而局部比对更加适用于evolution关系上关系比较远的（e.g. 水稻和葡萄）</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Youpu-Chen.github.io//post-images/1665210943785.png" alt="" loading="lazy"></figure>
<h1 id="步骤拆解global-alignment">「步骤拆解」Global Alignment</h1>
<p>利用动态规划来解决问题，最关键的一步就是列出<strong>动态规划公式</strong>，只要能列出公式，后面的编程也都只是时间问题。</p>
<p>但是，我并不想一上来就列出数学公式，我认为以一个简单的例子入手更有利于序列比对问题中的动态规划应用。</p>
<p>接下来，先理一理基于动态规划的序列比对的过程。</p>
<h2 id="1intialization-matrix-filling">（1）Intialization + Matrix Filling</h2>
<p>假设现在有2条长度分别为n、m的序列，</p>
<p>那则需要构建行数为n+1，列数为m+1的矩阵，</p>
<p>而“Filling”这个过程，即将第一列和第一行进行填充，从数学公式的角度来理解的话，</p>
<ul>
<li>第一列的填充：$$g*length(matrix[1:i, 1])$$，i~[1, n]</li>
<li>第一行的填充：$$g*length(matrix[1, 1:j])$$，j~[1, m]</li>
</ul>
<h2 id="2tracing-back">（2）Tracing Back</h2>
<p>每一个单元的填充模式如下，</p>
<ul>
<li>
<p>横向和竖向的移动代表了gap open（horizontal，vertical）</p>
<p>但更加复杂的情况应该考虑到gap在哪一条序列打开</p>
</li>
<li>
<p>对角线的移动则可以分为1）<strong>match</strong>（从大的数值回溯到小的数值），2）<strong>mismatch</strong>（从小的数值回溯到大的数值）</p>
</li>
</ul>
<p>Note：数值增大代表替换矩阵中，该碱基对应关系为match，而数值减小，代表替换矩阵中碱基对应关系为mismatch</p>
<figure data-type="image" tabindex="2"><img src="https://Youpu-Chen.github.io//post-images/1665210984762.png" alt="" loading="lazy"></figure>
<h1 id="公式global-alignment">「公式」Global Alignment</h1>
<figure data-type="image" tabindex="3"><img src="https://Youpu-Chen.github.io//post-images/1665211129642.png" alt="" loading="lazy"></figure>
<h1 id="引入gap-extension">引入gap extension</h1>
<p><strong>出现4个单位长度的一个完整gap将两条序列给比对上，或者4个单位长度的单独gap将两条序列给比对上是更符合生物学原理的</strong>？</p>
<p>上述的文字情况如下所示，</p>
<pre><code class="language-shell"># 1.
ATCGATCGATCGATCG----
AGCTAGCTCAGTACGT----
# 2.
ATCG-ATCG-ATCG-ATCG-ATCG
ATCG-ATCG-ATCG-ATCG-ATCG
</code></pre>
<p><a href="http://www.cs.otago.ac.nz/cosc348/alignments/Lecture05_GlobalAlignment.pdf">答案是前者</a>。这就需要在序列比对中引入另一个非常重要的细节 —— affine gap penalty。</p>
<blockquote>
<p>Note：此处引入的affine gap penalty为“not penalize open with extension”，即在打开一个gap的时候，不会在该gap上同时引入open和extension的罚分</p>
</blockquote>
<p>affine gap penalty，即在打开第一个gap的时候引入gap open罚分，而在该gap的基础上进行延续则采用gap extension罚分。</p>
<p>该种做法与原来的常量gap有一定区别，因此就需要改变动态规划公式，同时引入CS中的状态机可以帮助我们更好地理解这个问题。</p>
<figure data-type="image" tabindex="4"><img src="https://Youpu-Chen.github.io//post-images/1665211055133.png" alt="" loading="lazy"></figure>
<p>上图中存在3个状态，</p>
<p>1）M：当前的比对情况下为match或mismatch</p>
<p>2）Ix：当前的比对情况为在seq2上打开一个gap，而seq1上为一个base</p>
<p>3）Iy：当前的比对情况为在seq1上打开一个gap，而seq2上为一个base</p>
<p>三者之间是可以相互转换的，通过d、e、s(x, y)来调整。</p>
<p>因此动态规划公式变为如下的形式，</p>
<figure data-type="image" tabindex="5"><img src="https://Youpu-Chen.github.io//post-images/1665211100756.png" alt="" loading="lazy"></figure>
<h2 id="gap-extension情况下的动态规划矩阵初始化">gap extension情况下的动态规划矩阵初始化</h2>
<ul>
<li>M(0,0)=0</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo>)</mo><mo>=</mo><mi>d</mi><mo>+</mo><mi>e</mi><mo>∗</mo><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">I_{x}(i,0)=d + e*(i-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>y</mi></msub><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo>)</mo><mo>=</mo><mi>d</mi><mo>+</mo><mi>e</mi><mo>∗</mo><mo>(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">I_{y}(j,0)=d+e*(j-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<p>但由于$$I_{x}$$在第一行以及$$I_{y}$$在第一列的取值都是不存在的，因此定义为-inf。</p>
<p>同时，由于每一个cell都存在一种情况，我们需要建立3个矩阵来存储对应的信息，分别用M、X、Y来表示。</p>
<p>经初始化之后，就可以得到如下3个矩阵：</p>
<h4 id="1m">1）M</h4>
<figure data-type="image" tabindex="6"><img src="https://Youpu-Chen.github.io//post-images/1665211211305.png" alt="" loading="lazy"></figure>
<h4 id="2x">2）X</h4>
<p>代表在列方向打开一个gap，即seq2上插入一个gap</p>
<figure data-type="image" tabindex="7"><img src="https://Youpu-Chen.github.io//post-images/1665211230263.png" alt="" loading="lazy"></figure>
<h4 id="3y">3）Y</h4>
<p>代表在行方向上打开一个gap，即seq1上插入一个gap</p>
<figure data-type="image" tabindex="8"><img src="https://Youpu-Chen.github.io//post-images/1665211245230.png" alt="" loading="lazy"></figure>
<h3 id="gap-extension情况下的动态规划矩阵回溯">gap extension情况下的动态规划矩阵回溯</h3>
<p>3个矩阵，可以使用1个矩阵来记录当前的cell的数值来源，3种情况如下</p>
<ul>
<li>来自M，即当前为一个match/mismatch，记录为0</li>
<li>来自X，即当前为一个gap open/gap extension，记录为1</li>
<li>来自Y，即当前为一个gap open/gap extension，记录为2</li>
</ul>
<p>给个示例的回溯矩阵，</p>
<figure data-type="image" tabindex="9"><img src="https://Youpu-Chen.github.io//post-images/1665211266426.png" alt="" loading="lazy"></figure>
<h1 id="步骤拆解local-alignment">「步骤拆解」Local Alignment</h1>
<p>步骤与Global Alignment近似，只是引入了一个0，就可以得到局部的最佳匹配。</p>
<p>公式如下，</p>
<figure data-type="image" tabindex="10"><img src="https://Youpu-Chen.github.io//post-images/1665211285196.png" alt="" loading="lazy"></figure>
<h1 id="代码实现">代码实现</h1>
<pre><code class="language-python">import numpy as np

# Preset variables
seq1 = &quot;TCGTAGACGA&quot;
seq2 = &quot;ATAGAATGCGG&quot;
print(f'The seq1 has length of {len(seq1)}')
print(f'The seq2 has length of {len(seq2)}')

match = 1
mismatch = -1
gap_open = -2
gap_extension = -1
# 
global MIN
MIN = -float(&quot;inf&quot;)


def identity_match(base1, base2):
    '''Note: this function is used to compare the bases and return match point or mismatch point'''
    if base1 == base2:
        return match
    else:
        return mismatch

def createscorematrix(n, m):
    '''Note: this function is used to generate the original score function'''
    # Create match matrix, x matrix and y matrix
    m_mat = [np.zeros(m+1) for i in range(0, n+1)]
    x_mat = [np.zeros(m+1) for i in range(0, n+1)]
    y_mat = [np.zeros(m+1) for i in range(0, n+1)]

    return m_mat, x_mat, y_mat

m_mat, x_mat, y_mat = createscorematrix(len(seq1), len(seq2))
# print(m_mat)
# print(x_mat)
# print(y_mat)


def scorematrix_init(m_mat, x_mat, y_mat, d, e, local=False):
    '''Note: this function conduct the score matrix initialization'''
    '''Global Alignment'''
    if local == False:
        '''match matrix filling'''
        for i in range(0, len(m_mat)):
            for j in range(0, len(m_mat[0])):
                if i == 0 and j == 0:
                    m_mat[i][j] = 0
                elif i == 0 and j &gt; 0:
                    m_mat[i][j] = MIN
                elif i &gt; 0 and j == 0:
                    m_mat[i][j] = MIN
        # print(m_mat)
        for line in m_mat:
            r_list = [str(i) for i in line]
            print(' '.join(r_list))

        '''x_matrix filling'''
        for i in range(0, len(x_mat)):
            for j in range(0, len(x_mat[0])):
                if i == 0 and j == 0:
                    x_mat[i][j]=0
                if i &gt; 0 and j == 0:
                    x_mat[i][j] = d+e*(i-1)
        x_first_row = [0]
        x_first_row.extend([MIN]*(len(x_mat[0])-1))
        x_mat[0] = x_first_row
        # print(x_mat)
        for line in x_mat:
            r_list = [str(i) for i in line]
            print(' '.join(r_list))

        '''y_matrix filling'''
        for i in range(0, len(y_mat)):
            for j in range(0, len(y_mat[0])):
                if i == 0 and j == 0:
                    y_mat[i][j]=0
                elif i &gt; 0 and j == 0: 
                    y_mat[i][j] = MIN
        y_first_row = [0]
        y_first_row.extend([d+e*(i-1) for i in range(1, len(y_mat[0]-1))])
        y_mat[0] = y_first_row
        # print(y_mat)
        for line in y_mat:
            r_list = [str(i) for i in line]
            print(' '.join(r_list))

        return m_mat, x_mat, y_mat
    
    '''Local Alignment: Initialization step for Smith-Watermen is useless'''
    if local == True:
        return m_mat, x_mat, y_mat

m_mat, x_mat, y_mat = scorematrix_init(m_mat, x_mat, y_mat, -2, -1, local=False)
# m_mat, x_mat, y_mat = scorematrix_init(m_mat, x_mat, y_mat, -2, -1, local=True)


def matrix_filling(m_mat, x_mat, y_mat, d, e, local=False):
    '''this function is used to create the scoring matrix using three dynamic programming,
    and building a tracing matrix to restore the paths for the retrieve of aliignments'''
    '''Global Alignment Activation'''
    if local == False:
        # Filling score matrix and record the trace
        trace_matrix = [np.zeros(len(m_mat[0])) for i in range(0, len(m_mat))]

        for i in range(1, len(m_mat)):
            # print(m_mat[0])
            for j in range(1, len(m_mat[0])):
                # print(i, j)
                m_mat[i][j] = max(
                    m_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1]),
                    x_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1]),
                    y_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1])
                )
                x_mat[i][j] = max(m_mat[i-1][j] + d, x_mat[i-1][j] + e)
                y_mat[i][j] = max(m_mat[i][j-1] + d, y_mat[i][j-1] + e)
        # for line in m_mat:
        #     print(line)

        # Take the greatest values in these three matrix,
        # merge into one matrix,
        # and record the path
        new_mat = [np.zeros(len(m_mat[0])) for i in range(0, len(m_mat))]
        for i in range(0, len(m_mat)):
            for j in range(0, len(m_mat[0])):
                new_mat[i][j] = max(m_mat[i][j], x_mat[i][j], y_mat[i][j])
                # Fill the trace matrix
                # Note: from match/mismatch is 0, from x_mat (open a gap in seq2) is 1, from y_mat (open a gap in seq1)
                if m_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 0
                elif x_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 1
                elif y_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 2
        # # Print out the scoring matrix
        # for line in new_mat:
        #     r_list = [str(i) for i in line]
        #     print('\t'.join(r_list))
        # # Print out the tracing matrix
        for line in trace_matrix:
            r_list = [str(i) for i in line]
            print('\t'.join(r_list))

        return new_mat, trace_matrix
    
    '''Local Alignment Activation'''
    if local == True:
        # Filling score matrix and record the trace
        trace_matrix = [np.zeros(len(m_mat[0])) for i in range(0, len(m_mat))]

        for i in range(1, len(m_mat)):
            # print(m_mat[0])
            for j in range(1, len(m_mat[0])):
                # print(i, j)
                m_mat[i][j] = max(
                    m_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1]),
                    x_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1]),
                    y_mat[i-1][j-1] + identity_match(seq1[i-1], seq2[j-1]),
                    0
                )
                x_mat[i][j] = max(m_mat[i-1][j] + d, x_mat[i-1][j] + e)
                y_mat[i][j] = max(m_mat[i][j-1] + d, y_mat[i][j-1] + e)
        # for line in m_mat:
        #     print(line)

        # Take the Greatest values in these three matrix
        new_mat = [np.zeros(len(m_mat[0])) for i in range(0, len(m_mat))]
        for i in range(0, len(m_mat)):
            for j in range(0, len(m_mat[0])):
                new_mat[i][j] = max(m_mat[i][j], x_mat[i][j], y_mat[i][j])
                if m_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 0
                elif x_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 1
                elif y_mat[i][j] == max(m_mat[i][j], x_mat[i][j], y_mat[i][j]):
                    trace_matrix[i][j] = 2
        
        # # Print out the scoring matrix
        # for line in new_mat:
        #     r_list = [str(i) for i in line]
        #     print(' '.join(r_list))
        # # Print out the tracing matrix
        # for line in trace_matrix:
        #     r_list = [str(i) for i in line]
        #     print('\t'.join(r_list))
        return new_mat, trace_matrix

score_matrix, trace_matrix = matrix_filling(m_mat, x_mat, y_mat, -2, -1, local=False)
# score_matrix, trace_matrix = matrix_filling(m_mat, x_mat, y_mat, -2, -1, local=True)

# seq1 = &quot;-TCGTAGACGA&quot;
# seq2 = &quot;ATAGAATGCGG&quot;
def global_backtracking(matrix, score_matrix):
    '''this function is used to trace back the input matrix and output the final alignment
    Note: the input matrix is trace matrix'''
    ti = len(seq1)
    tj = len(seq2)
    alignment1 = ''
    alignment2 = ''
    while (ti &gt; 0 or tj &gt; 0):
        # Choose to go left, up or diagonal
        cell = matrix[ti][tj]
        if cell == 0:
            alignment1 = seq1[ti-1] + alignment1
            alignment2 = seq2[tj-1] + alignment2
            ti -= 1
            tj -= 1
        elif cell == 1:
            alignment1 = seq1[ti-1] + alignment1
            alignment2 = '-' + alignment2
            ti -= 1
        elif cell == 2:
            alignment1 = '-' + alignment1
            alignment2 = seq2[tj-1] + alignment2
            tj -= 1

    # fmt_alignment = f'{alignment1}\n{alignment2}'
    # print(fmt_alignment)
    # Formt the info
    info = f&quot;======The Global======\n     {alignment1}\n     {alignment2}\nSCORE: {score_matrix[len(score_matrix)-1][len(score_matrix[0])-1]}&quot;
    print(info)
global_backtracking(trace_matrix, score_matrix)


def local_backtracking(trace_matrix, score_matrix):
    '''this function does backtracking like FUNCTION global_backtracking, but in the way of local aligment'''
    # Convert score matrix into Numpy array to find maximum value
    new_score_matrix = np.array(score_matrix)
    pos = np.unravel_index(np.argmax(new_score_matrix, axis=None), new_score_matrix.shape)  # retrieve the maximum value
    ti = pos[0]
    tj = pos[1]
    # print(f'{ti}\t{tj}')
    alignment1 = ''
    alignment2 = ''

    while (ti &gt; 0 or tj &gt; 0):

        if new_score_matrix[ti][tj] == 0: # stop local alignment back tracking when 0 values met
            break
        
        cell = trace_matrix[ti][tj]
        if cell == 0:
            alignment1 = seq1[ti-1] + alignment1
            alignment2 = seq2[tj-1] + alignment2
            ti -= 1
            tj -= 1
        elif cell == 1:
            alignment1 = seq1[ti-1] + alignment1
            alignment2 = '-' + alignment2
            ti -= 1
        elif cell == 2:
            alignment1 = '-' + alignment1
            alignment2 = seq2[tj-1] + alignment2
            tj -= 1
    info = f&quot;======The Local======\n     {alignment1}\n     {alignment2}\nSCORE: {np.ndarray.max(new_score_matrix)}&quot;
    print(info)

# local_backtracking(trace_matrix, score_matrix)
</code></pre>
<h1 id="参考文献">参考文献</h1>
<p>[1] 《组学数据中的统计与分析》，田卫东</p>
<p>[2] https://users.soe.ucsc.edu/~karplus/bme205/f12/Alignment.html</p>
<p>[3] https://www.youtube.com/watch?v=ZBD9he4Zp1E</p>
<p>[4] Biological sequence analysis: Probabilistic models of proteins and nucleic acids</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从读者的角度出发]]></title>
        <id>https://Youpu-Chen.github.io/post/for-readers/</id>
        <link href="https://Youpu-Chen.github.io/post/for-readers/">
        </link>
        <updated>2022-09-24T13:21:59.000Z</updated>
        <content type="html"><![CDATA[<p>虽然没有一头想着要搞科研的打算，但是有着想要在活着的时候做一些自己觉得有意思的事情作为出发点，开始了我新阶段的学习，尽管现在还没有如愿。</p>
<p>新的学期，我选了一门课，名为《科研之道》。</p>
<p>今天的课上的内容对我非常有启发性，因此就想着来写篇文章记录一下。</p>
<h1 id="如何做好的科研">如何做好的科研？</h1>
<p>1）科研工作好是第一位，只有好的工作最终才有可能被认可。</p>
<p>此处引发出另一个问题：如何做好的工作？</p>
<p>2）<strong>科研成果的展示是重要的</strong>：更容易获得认可和科研资源、可能让成功早来11年、展示不好可能错过重要机会。</p>
<p>另一个问题：如何展示？</p>
<p>3）科研成果被抢发之后：不要气馁，积极展示自己的创新，争取最终的成果。</p>
<p>最后一个问题：被抢发之后，是模仿别人，还是坚持自己的风格？</p>
<h1 id="如何展示科研工作">如何展示科研工作？</h1>
<p>展示科研工作是为了让别人知晓并欣赏自己的科学发现。</p>
<p>说实话，我很多时候并不认为科研只要是自己感兴趣就好了，它必须具有一定的社会意义和现实意义，科研不应该是象牙塔，如果最终的成果不能反馈到社会上，未免显得有些浪费资源。在此处聊到这个话题，显得有些偏题，以后等自己阅历更加丰富了有时间坐下来慢慢写文章了再聊。</p>
<p>如何展示，更深层次的一个问题是：展示科研工作的对象是谁？</p>
<p>如果搞不清展示的对象，自顾自得写，就算写得再好又有什么用呢？</p>
<p>自己欣赏自己，自己觉得自己是张锋、Craig Ventor，有什么用呢？</p>
<p>因此弄清楚展示科研工作的对象非常重要，这个问题需要站在阅读者的立场上思考，因为最终都是文章能否发表、能否被引用都是从“读者”身上得来的反馈。</p>
<p>这给我的启发非常之大，让我意识到我有时写博客，就自顾自地写，并没有考虑到读者的感受，因此这也将是我下一个阶段要努力提升的目标，</p>
<p>先将自己丰富，再将知识简单地输出，让我的博客通俗易懂。</p>
<h1 id="参考资料">参考资料</h1>
<p>[1] 《科研之道》，鲁伯埙</p>
<p>[2] Millisecond-timescale, genetically targeted optical control of neural activity</p>
<p>[2] Functional Expression of a Directly Light–Gated Membrane Channel in Mammalian Retinal Neurons: A Potential Strategy for Restoring Light Sensitivity to the Retina After Photoreceptor Degeneration</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「转录组」WGCNA专题：实战原理两不误]]></title>
        <id>https://Youpu-Chen.github.io/post/WGCNA/</id>
        <link href="https://Youpu-Chen.github.io/post/WGCNA/">
        </link>
        <updated>2022-08-23T13:50:06.000Z</updated>
        <content type="html"><![CDATA[<p>Hello，这里是即将开学的陈有朴。</p>
<h1 id="表达矩阵的处理">表达矩阵的处理</h1>
<p>后续分析所用到的数据，均为FPKM标准化后的表达矩阵。</p>
<h1 id="从流程上对wgcna进行解读">从流程上对WGCNA进行解读</h1>
<h2 id="1当对芯片数据或者rna-seq等数据完成分析之后我们可以得到一张表达矩阵">1）当对芯片数据或者RNA-Seq等数据完成分析之后，我们可以得到一张表达矩阵</h2>
<p>一行为一个样本，一列为一个gene。</p>
<h2 id="2读取表达矩阵之后对其进行adjacency矩阵的计算">2）读取表达矩阵之后，对其进行adjacency矩阵的计算</h2>
<p>adjacency矩阵，基于gene之间相关性的矩阵。每一个单元代表了2个gene之间的关联性（similarity）。</p>
<p>adjacency矩阵的构建，涉及到软阈值的选择，即构建一个幂函数，选择一个指数（power），强化强相关性，弱化弱相关性。</p>
<h3 id="adjacency矩阵的拓展">「adjacency矩阵的拓展」</h3>
<p>adjacency矩阵有2种计算方式，</p>
<p>1）unsigned：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>r</mi><mo>(</mo><msub><mi>x</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo><msup><mi mathvariant="normal">∣</mi><mi>β</mi></msup></mrow><annotation encoding="application/x-tex">a_{ij} = |cor(x_{x}, x_{j})|^{β}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1352159999999998em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>2）signed：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo>(</mo><mn>0.5</mn><mo>∗</mo><mo>(</mo><mn>1</mn><mo>+</mo><mi>c</mi><mi>o</mi><mi>r</mi><mo>)</mo><msup><mo>)</mo><mi>β</mi></msup></mrow><annotation encoding="application/x-tex">a_{ij}=(0.5*(1+cor))^{β}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>第一种情况，认为具有高负相关的gene之间，是有联系的。</p>
<p>第二种情况，认为具有高负相关的gene之间，是没有联系的。</p>
<p>举个例子，</p>
<p>假设cor = -1，β=2，unsigned情况下，计算得到的adjacency为1，即gene之间高度关联。signed情况下，计算得到的adjacency为0，即gene之间无关联。</p>
<h2 id="3tom矩阵的构建">3）TOM矩阵的构建</h2>
<p>引入一个指标，即topological overlaps的计算，用于定义该gene是否有多个高关联性的gene（<font color='yellow'>用于gene module的构建</font>）</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>r</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>T</mi><mi>O</mi><mi>M</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Cor(x_{i},x_{j}) -&gt; TOM(x_{i}, x_{j})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="tom矩阵的拓展">「TOM矩阵的拓展」</h3>
<p>但是针对unsigned类型的adjacency矩阵，可能会出现无法判断几个基因之间的关联关系。</p>
<p>比如现有i，j，k 3个gene，计算得到它们之间的关联关系为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>+</mo><mo separator="true">,</mo><mo>+</mo><mo separator="true">,</mo><mo>−</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(+,+,-)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">+</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mclose">)</span></span></span></span>，</p>
<p>1）i和j之间为正相关；2）i和k之间为正相关；3）j和k之间为负相关。</p>
<p>这就矛盾了，说明上面的关联关系可能受到了一些噪音的影响等等。</p>
<p><u>此时，引入signed TOM</u>，其相较于unsigned TOM能够更好的解决gene之间的冲突情况。</p>
<blockquote>
<p>Note：需要注意的是，当使用signed adjacency进行分析时，不会出现上述矛盾。</p>
<p>同时，这些矛盾作者都已经考虑到了，但还是有一定区别，</p>
<ul>
<li><code>TOMsimilarity()</code>中，默认设置为<code>TOMType = &quot;unsigned&quot;</code></li>
<li><code>TOMsimilarityFromExpr()</code>中，默认设置为<code>TOMType = &quot;signed&quot;</code></li>
</ul>
</blockquote>
<h2 id="4tom-dissimilarity矩阵的构建">4）TOM dissimilarity矩阵的构建</h2>
<p>TOM dissimilarity矩阵代表了某个gene与其他gene之间的距离。</p>
<p>用上述矩阵进行聚类分析，得到gene module。</p>
<h2 id="5初步构建gene-module">5）初步构建gene module</h2>
<p>以TOM dissimilarity矩阵作为输入，进行聚类分析。</p>
<p>代码如下，</p>
<pre><code class="language-R"># Turn data expression into topological overlap matrix
power=sft$powerEstimate   # 使用sft$powerEstimate调用预估出的软阈值
TOM = TOMsimilarityFromExpr(datExpr, power = power)
dissTOM = 1-TOM
# Plot gene tree
geneTree = hclust(as.dist(dissTOM), method = &quot;average&quot;);   # 用于后续cutreeDynamic()，对gene tree进行裁剪
# pdf(file = &quot;3-gene_cluster.pdf&quot;, width = 12, height = 9);
plot(geneTree, xlab=&quot;&quot;, sub=&quot;&quot;, main = &quot;Gene clustering on TOM-based dissimilarity&quot;,
     labels = FALSE, hang = 0.04);
# dev.off()
</code></pre>
<h2 id="6使用cutreedynamic进行聚类分析的优化">6）使用<code>cutreeDynamic()</code>进行聚类分析的优化</h2>
<p>使用<font color='yellow'>pairwise eigengene</font>，进一步计算得到eigengene dissimilarity，用于聚类分析，筛选指标，最终合并gene module。</p>
<blockquote>
<p>Note：eigengene为gene表达模式的指标（PCA降维得到的第一个主成分）</p>
</blockquote>
<p><code>cutreeDynamic()</code>代码如下，</p>
<ul>
<li><code>cutreeDynamic</code></li>
<li><code>labels2colors</code></li>
<li><code>plotDendroAndColors</code></li>
</ul>
<pre><code class="language-R"># Module identification using dynamic tree cut
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = 2, 
                            pamRespectsDendro = FALSE, minClusterSize = 30);
table(dynamicMods)
length(table(dynamicMods)) 
# Convert numeric labels into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
# pdf(file = &quot;4-module_tree.pdf&quot;, width = 8, height = 6);
plotDendroAndColors(geneTree, dynamicColors, &quot;Dynamic Tree Cut&quot;,dendroLabels = FALSE,
                    hang = 0.03,addGuide = TRUE, guideHang = 0.05,main = &quot;Gene dendrogram and module colors&quot;)
# dev.off()
</code></pre>
<p>绘制图如下，<br>
<img src="https://Youpu-Chen.github.io//post-images/1661263419560.png" alt="" loading="lazy"></p>
<p>gene module合并代码如下 -&gt; 基于<code>cutreeDynamic()</code>的分析结果进行聚类分析的gene module的合并</p>
<ul>
<li><code>mergeCloseModules</code>：合并gene module</li>
<li><code>plotDendroAndColors</code></li>
</ul>
<pre><code class="language-R"># Merge close modules
MEDissThres=0.25
abline(h=MEDissThres, col = &quot;red&quot;)
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3) 
mergedColors = merge$colors  
mergedMEs = merge$newMEs  
# Plot merged module tree
# pdf(file = &quot;5-merged_Module_Tree.pdf&quot;, width = 12, height = 9)  
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), 
                    c(&quot;Dynamic Tree Cut&quot;, &quot;Merged dynamic&quot;), dendroLabels = FALSE, 
                    hang = 0.03, addGuide = TRUE, guideHang = 0.05)  
# dev.off()
# merge$oldMEs，为数据框，行为样本，列为对应的gene module，其中的数值代表了它们之间的关联度
write.table(merge$oldMEs,file=&quot;oldMEs.txt&quot;);
write.table(merge$newMEs,file=&quot;newMEs.txt&quot;);
</code></pre>
<p>绘制图如下，可以看到有一些gene module被合并了，</p>
<figure data-type="image" tabindex="1"><img src="https://Youpu-Chen.github.io//post-images/1661263433346.png" alt="" loading="lazy"></figure>
<h2 id="7将gene-module与表型特征相联系">7）将gene module与表型特征相联系</h2>
<p>使用标准化的eigengene进行计算。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi>M</mi><mi>E</mi><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">
Cor(MEs, Traits)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span><br>
代码如下，</p>
<ul>
<li><code>moduleEigengenes</code>，计算每个gene module的特征值</li>
<li><code>moduleTraitCor = cor(MEs, datTraits, use = &quot;p&quot;)</code></li>
<li><code>moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)</code></li>
</ul>
<pre><code class="language-R"># Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, mergedColors)$eigengenes
MEs = orderMEs(MEs0)
# r$&gt; MEs[1:5, 1:5]
#           MElightcyan1 MEdarkolivegreen MEgreenyellow       MEcyan     MEwhite
# LH38_Z1_1    0.3093871      -0.01665288     0.1583588 -0.017809267 -0.01305706
# LH38_Z1_2    0.3318247      -0.01679628     0.1629585 -0.010450719  0.04613664
# LH38_Z1_3    0.3087032      -0.01762908     0.1527085 -0.018456470 -0.03661408
# LH38_Z2_1    0.3050361      -0.01431782     0.1589569 -0.020199995  0.06161998
# LH38_Z2_2    0.3422982      -0.01466196     0.1722949 -0.006663298  0.08192540

# 一些数据处理部分
# Read microbial data as traits
bac_traits = read.table(&quot;traits_file/b_order_234.txt&quot;, header = T, sep = &quot;\t&quot;)
rownames(bac_traits) = bac_traits[, 1]
bac_traits = bac_traits[, -1]
# r$&gt; bac_traits[1:5, 1:5]
#           Pseudomonadales Enterobacteriales Xanthomonadales Burkholderiales Verrucomicrobiales
# LH38_Z1_1      0.02120943       0.006338742      0.07261663      0.05920385         0.02674949
# LH38_Z1_2      0.04192444       0.009089757      0.06880071      0.05583164         0.02156440
# LH38_Z1_3      0.01393256       0.004525862      0.06961207      0.05100152         0.02189402
# LH39_Z1_1      0.11288033       0.013045132      0.07138692      0.04186106         0.01743154
# LH39_Z1_2      0.01214503       0.003410243      0.08236562      0.03733519         0.01953600


rownames(MEs) = paste(substr(rownames(MEs), 1, nchar(rownames(MEs))-1), rep(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), 60), sep = &quot;&quot;)
# sample names should be consistent in eigen genes and traits !!!!
bac_traits = bac_traits[match(rownames(MEs), rownames(bac_traits)), ]
table(rownames(MEs) == rownames(bac_traits))

# Calculate pearson correlation coefficients between module eigen-genes and traits
moduleTraitCor = cor(MEs, bac_traits, use = &quot;p&quot;);
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
write.table(moduleTraitCor,file=&quot;moduleTrait_correlation.txt&quot;);
write.table(moduleTraitPvalue,file=&quot;moduleTrait_pValue.txt&quot;);
</code></pre>
<p>结果图可视化代码如下，</p>
<pre><code class="language-R">sizeGrWindow(10,6)
# Will display correlations and their p-values
# 合并
textMatrix =  paste(signif(moduleTraitCor, 2), &quot;\n(&quot;,
                    signif(moduleTraitPvalue, 1), &quot;)&quot;, sep = &quot;&quot;);
dim(textMatrix) = dim(moduleTraitCor)
# pdf(&quot;module-traits-bacteria-order.pdf&quot;, width = 100, height = 30)
par(mar = c(15, 12, 5, 5));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(bac_traits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,  # 矩阵单元格上需要显示的信息
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste(&quot;Module-trait relationships&quot;))
# dev.off()
</code></pre>
<p>结果图如下，</p>
<blockquote>
<p>Note：右边的图例，代表相关性程度</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://Youpu-Chen.github.io//post-images/1661263448767.png" alt="" loading="lazy"></figure>
<h2 id="8hub-gene的鉴定">8）Hub gene的鉴定</h2>
<p>2种方法，</p>
<ul>
<li>与目标module有强关联性的gene（gene significance）</li>
<li>使用module membership来鉴定关键gene，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>M</mi><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Cor(i,ME)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>一般先绘制出以module membership为x，gene significance为y的散点图。</p>
<p>代码如下，</p>
<pre><code class="language-R"># 以相关性最高的模块为例
which(moduleTraitCor == max(moduleTraitCor, na.rm = TRUE), arr.ind = TRUE)
#            row col
# MEskyblue3  25  30

Nitrosomonadales &lt;- as.data.frame(bac_traits[, 30])
names(Nitrosomonadales) = &quot;Nitrosomonadales&quot;

modNames = substring(names(MEs), 3) # 去除ME前缀

# 计算module membership
# 使用的是WGCNA自带cor函数，使用皮尔逊计算相关性
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = &quot;p&quot;));
geneModuleMembership[1:5, 1:5]
#                MElightcyan1 MEdarkolivegreen MEgreenyellow      MEcyan       MEwhite
# Zm00001d001763 -0.045547074      -0.10334193   -0.20030129  0.22671189  0.1501121833
# Zm00001d001766  0.004752275      -0.01548396   -0.11130522 -0.22346048  0.0178421845
# Zm00001d001770 -0.286230379      -0.23340743   -0.39930773  0.22791746  0.0925346831
# Zm00001d001774  0.029505956      -0.06714112   -0.06323784 -0.34302212  0.1677206174
# Zm00001d001775 -0.029767437      -0.07642270   -0.13732818 -0.07876773 -0.0008678361

MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
MMPvalue[1:5, 1:5]

names(geneModuleMembership) = paste(&quot;MM&quot;, modNames, sep=&quot;&quot;);
names(MMPvalue) = paste(&quot;p.MM&quot;, modNames, sep=&quot;&quot;);

# 计算gene significance
geneTraitSignificance = as.data.frame(cor(datExpr, Nitrosomonadales, use = &quot;p&quot;));
# head(geneTraitSignificance)
# nrow(geneTraitSignificance)
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste(&quot;GS.&quot;, names(Nitrosomonadales), sep=&quot;&quot;);
names(GSPvalue) = paste(&quot;p.GS.&quot;, names(Nitrosomonadales), sep=&quot;&quot;);


module = &quot;skyblue3&quot;
column = match(module, modNames);  # match(x, y)，找到y中x的索引位置
moduleGenes = mergedColors==module;
# length(mergedColors)
# nrow(geneModuleMembership)
# nrow(geneTraitSignificance)
# table(mergedColors)
table(moduleGenes)

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste(&quot;Module Membership in&quot;, module, &quot;module&quot;),
                   ylab = &quot;Gene significance for Nitrosomonadales&quot;,
                   main = paste(&quot;Module membership vs. gene significance\n&quot;),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
</code></pre>
<p>散点图结果如下，可以看到module membership值越高的gene，其gene significance也越高。</p>
<figure data-type="image" tabindex="3"><img src="https://Youpu-Chen.github.io//post-images/1661263464074.png" alt="" loading="lazy"></figure>
<h1 id="其他">其他</h1>
<h2 id="绘制gene-module-eigengenes与samples之间的热图">绘制gene module eigengenes与samples之间的热图</h2>
<pre><code class="language-R">library(&quot;pheatmap&quot;)

# Heatmap of old module eigen-genes and samples
pdf(file=&quot;oldMEs.pdf&quot;,heigh=80,width=20)
row.names(merge$oldMEs)=names(data0)  # oldMEs，是一个矩阵
pheatmap(merge$oldMEs,cluster_col=T,cluster_row=T,show_rownames=T,show_colnames=T,fontsize=6)
dev.off()

# Heatmap of new module eigen-genes and samples
# pdf(file=&quot;newMEs.pdf&quot;,heigh=60,width=20)
row.names(merge$newMEs)=names(data0)
pheatmap(merge$newMEs,cluster_col=T,cluster_row=T,show_rownames=T,show_colnames=T,fontsize=6)
# dev.off()
</code></pre>
<h1 id="参考资料">参考资料</h1>
<p>[1] https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/</p>
<p>[2] https://github.com/PengYuMaize/Yu2021NaturePlants</p>
<p>[3] <a href="https://www.jianshu.com/p/a19e335f057a">跟着Nature Plants学数据分析：R语言WGCNA分析完整示例</a></p>
<p>[4] https://www.youtube.com/watch?v=BzYfg1lO3jw</p>
<p>[5] https://www.biostars.org/p/288153/</p>
<p>[6] https://peterlangfelder.com/2018/11/25/signed-or-unsigned-which-network-type-is-preferable/</p>
<p>[7] https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/TechnicalReports/signedTOM.pdf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写给二十二岁的自己]]></title>
        <id>https://Youpu-Chen.github.io/post/tomy22/</id>
        <link href="https://Youpu-Chen.github.io/post/tomy22/">
        </link>
        <updated>2022-08-14T06:47:00.000Z</updated>
        <content type="html"><![CDATA[<p>写下这篇文章的时候，我的生日已经过去了二十多天，但或许是近来反刍的事情太多，才让我写下这篇文章。</p>
<p>现在这个时代太快了，包含的信息太多了，逼迫我的脑容量和身体不断成长。</p>
<p>我看的书不多，主要看的也就是一些心理学方面的书，关于自我成长，也爱看王小波写的杂文，像什么《一只特立独行的猪》、《爱你就像爱生命》等等，但把后一本归为杂文不太对头，就算方便我归纳了吧。</p>
<p>细腻的文字，很多时候被视作腻腻歪歪，但是对我来说，我却像如获至宝一样。</p>
<p>也就像大学四年，挖掘自己喜欢的东西、想要在自己追求的东西上做出一些成绩，很多时候被视作只会读书一般。</p>
<p>但是，我也凭借这“只会读书”，在四年后的今天能够堂堂正正走进上海五角场文秘职业技术学院。</p>
<p>悲观主义，是很多人身上都具有的一种鲜明色彩，仿佛活着就是在等待更大的负彩降临到自己身上。我可能也不例外，但是这更显得如今的开朗更加珍贵。</p>
<p>想写给经历了很多事情的二十二岁的自己，几句话，就当是应对未来的负彩而做的准备。</p>
<p>1）要感恩朋友和家人，是他们在背后默默支撑着你。</p>
<blockquote>
<p>《Love will set you free》，Kodaline</p>
</blockquote>
<p>2）Be a lovely person, and to love people and dare to hate people.</p>
<blockquote>
<p>&quot;You want to spend all the day on people you hate or the people you love?&quot;<br>
&quot;Hate or love?&quot; —— adopted from《tick, tick, Boom!》</p>
</blockquote>
<p>我非常喜欢的作品《ハイキュー!!》中有一个人物，名为木兔光太郎。人如其名，总是用自己的行动来带动周围的人，不去谈所谓的崇高，也没有用所谓的崇高去强迫他人，虽时有低谷，但是正是因为他所作所为，大家也都默默支持着他。</p>
<p>3）总会走到理想的道路上，只是有时候绕远路是捷径罢了。</p>
<blockquote>
<p>摘自《Steel Ball Run》</p>
</blockquote>
<p>4）活成自己想要成为的样子，总有人会挑你的刺</p>
<blockquote>
<ul>
<li>&quot;I can do all things.&quot;  —— Stephen Curry</li>
<li>&quot;You don't want to see us next year.&quot;  —— Stephen Curry</li>
<li>“你生命里的那张纸牌，哦那是张王牌，还是等待？如果是等待，就这样等待，你还是不会，轻易的就把手举起来。” —— 《表态》，梁博</li>
<li>等我回天津摆佛龛 —— 《深海》，刘森</li>
</ul>
</blockquote>
<p>5）别太压榨自己</p>
<blockquote>
<p>黑暗好像，一颗巨石，按在胸口 —— 《大石碎胸口》，万能青年乐队</p>
</blockquote>
<p>6）快乐从现在开始，不要总想着延迟自己的快乐（摘自哈佛积极心理学）</p>
<p>7）有好奇心是好的，但是不能想着一口吃成胖子，要分清楚轻重。</p>
<blockquote>
<p>谢谢李同学</p>
</blockquote>
<p>8）不要想着第一遍就把工作做好，先把代码跑起来，细节什么的，之后再考虑</p>
<blockquote>
<p>2022年的暑假，最有价值的40分钟竟诞生的如此突然。从心底里感谢我的师兄。</p>
</blockquote>
<p>9）人生应该要做减法，不要和自己过不去</p>
<blockquote>
<p>chipping away the excessive stones</p>
</blockquote>
<h1 id="后话">后话</h1>
<p>感觉做成了一档音乐分享节目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这可能是我写过最全的GATK笔记]]></title>
        <id>https://Youpu-Chen.github.io/post/GATK-BESTPRACTICE/</id>
        <link href="https://Youpu-Chen.github.io/post/GATK-BESTPRACTICE/">
        </link>
        <updated>2022-08-11T03:23:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="软件安装">软件安装</h3>
<p>官方网站：https://gatk.broadinstitute.org/hc/en-us</p>
<p>点击“Download GATK4”：<br>
<img src="https://Youpu-Chen.github.io//post-images/1660188520935.png" alt="" loading="lazy"></p>
<p>选择zip安装包：<br>
<img src="https://Youpu-Chen.github.io//post-images/1660188530491.png" alt="" loading="lazy"></p>
<pre><code class="language-bash">wget https://github.com/broadinstitute/gatk/releases/download/4.2.5.0/gatk-4.2.5.0.zip
unzip gatk-4.2.5.0.zip
</code></pre>
<h4 id="其他">其他</h4>
<p>安装GATK Best Practice所需要的软件：https://gatk.broadinstitute.org/hc/en-us/articles/360041320571--How-to-Install-all-software-packages-required-to-follow-the-GATK-Best-Practices</p>
<p>其他分析流程（bwa替代流程）：https://gatk.broadinstitute.org/hc/en-us/articles/4407897446939--How-to-Run-germline-single-sample-short-variant-discovery-in-DRAGEN-mode</p>
<h3 id="gatkjave选项">GATK：Jave选项</h3>
<p>GATK实际使用的命令为：<code>java -jar program.jar</code>，但是为了GATK的开发者为了方便将其添加到环境变量，对其进行了封装，即使用安装目录下的<strong>gatk可执行脚本</strong>可直接运行：<br>
<img src="https://Youpu-Chen.github.io//post-images/1660188563873.png" alt="" loading="lazy"></p>
<p>下面给出一个封装前后，设置额外参数的例子：</p>
<p>未进行封装前，设置额外参数的方式为<code>java -Xmx4G -jar gatk-package-4.2.2.0-local.jar</code></p>
<p>进行封装后，设置额外参数的方式为<code>gatk --java-options &quot;-Xmx4G&quot;</code></p>
<p>官方文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360035531892-GATK4-command-line-syntax</p>
<h3 id="gatkhallotypecaller">GATK：HallotypeCaller</h3>
<p>关于HallotypeCaller（GATK 3.6之后的版本）是否还需要使用重比对？</p>
<p>答案是不需要。</p>
<p>细节请看：</p>
<p>[1] https://github.com/broadinstitute/gatk-docs/blob/master/blog-2012-to-2019/2016-06-21-Changing_workflows_around_calling_SNPs_and_indels.md?id=7847</p>
<h3 id="gatkgenomicsdbimport">GATK：GenomicsDBImport</h3>
<p>在完成gatk HallotypeCaller分析这一步之后，可以选择GenomicsDBImport将生成的gvcf文件进行整合，便于后续的joint genotyping。</p>
<p>【标注】</p>
<ul>
<li>“GATK4 Best Practice for SNP and Indel”一般都选择GenomicsDBImport（而不是CombineGVCFs）进行gvcf文件的合并。GenomicsDBImport<strong>有一套独立的数据存储系统</strong>；</li>
<li>GenomicsDBImport与CombineGVCFs功能类似 —— 合并gvcf文件。前者将genomic loci作为划分依据（e.g. chromosome, scaffold, contig），后者使用sample；</li>
<li>可以使用SelectVariants，对GenomicsDBImport产生的数据库内容进行访问；</li>
</ul>
<h4 id="要求输入数据">要求输入数据</h4>
<p>GenomicsDBImport所要求的输入数据，为HallotypeCaller添加<code>-ERC GVCF</code>或<code>-ERC BP_RESOLUTION</code>参数生成的结果文件，即gvcf文件。</p>
<h4 id="参数设置强制要求">参数设置（强制要求）</h4>
<p>运行GenomicsDBImport的时候，有一些参数是必须的，还有一些参数是额外设置，可以用于增大文件读取速度或者进行个性化分析。</p>
<pre><code class="language-bash">--genomicsdb-workspace-path  # 构建GenomicsDatabase的目标文件夹
-V                           # gvcf文件名
--sample-name-map            # 一个包含所有gvcf ID的文本，使用tab分隔符，第一列为sample ID，第二列为gvcf ID
-L | --intervals             # 选择需要合并的基因组区域（每一行一个染色体编号）
</code></pre>
<p>额外参数设置：</p>
<pre><code class="language-bash">--batch-size        # 代表每批次能够读入多少个样本，默认为0，表示一次性全部读入。当样本数超过100时需要注意
</code></pre>
<h4 id="输入文件">输入文件</h4>
<p>GenomicsDBImport特殊的数据存储格式（e.g. ）</p>
<h4 id="genomicsdbimport示例代码">GenomicsDBImport：示例代码</h4>
<pre><code class="language-bash"># 每一个sample gvcf作为输入文件
gatk --java-options &quot;-Xmx4g -Xms4g&quot; GenomicsDBImport \
  -V data/gvcfs/mother.g.vcf.gz \
  -V data/gvcfs/father.g.vcf.gz \
  -V data/gvcfs/son.g.vcf.gz \
  --genomicsdb-workspace-path my_database \
  --tmp-dir=/path/to/large/tmp \
  -L 20

# 将所有sample gvcf名称放入map文件中
# 对应参数：--sample-name-map
gatk --java-options &quot;-Xmx4g -Xms4g&quot; \
   GenomicsDBImport \
   --genomicsdb-workspace-path my_database \
   --batch-size 50 \
   -L chr1:1000-10000 \
   --sample-name-map cohort.sample_map \
   --tmp-dir /path/to/large/tmp \
   --reader-threads 5

# 将新sample添加到GenomicsDBImport数据库中
# 对应参数：--genomicsdb-update-workspace-path
gatk --java-options &quot;-Xmx4g -Xms4g&quot; GenomicsDBImport \
  -V data/gvcfs/mother.g.vcf.gz \
  -V data/gvcfs/father.g.vcf.gz \
  -V data/gvcfs/son.g.vcf.gz \
  --genomicsdb-update-workspace-path my_database \
  --tmp-dir /path/to/large/tmp \
</code></pre>
<p>【标注】sample map文件使用tab分隔符，每一行一个gvcf文件名</p>
<pre><code class="language-bash">sample1      sample1.vcf.gz
sample2      sample2.vcf.gz
sample3      sample3.vcf.gz
</code></pre>
<p>还有一些细节就看看官方文档吧~</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360057439331-GenomicsDBImport</p>
<p>[2] https://github.com/GenomicsDB/GenomicsDB/wiki</p>
<h3 id="gatkcombinegvcfs">GATK：CombineGVCFs</h3>
<p>CombineGVCFs的主要功能就是将<strong>HaplotypeCaller</strong>产生的gvcf文件，给合并。</p>
<p>【标注】</p>
<ul>
<li>有且只能是HaplotypeCaller产生的gvcf可以用作输入文件</li>
<li>VCF文件的合并，使用的是MergeVcfs，是Picard下的一个工具</li>
<li>官方给出的说明是：1000+以上的样本推荐使用GenomicsDBImport</li>
</ul>
<h4 id="combinegvcfs示例代码">CombineGVCFs：示例代码</h4>
<pre><code class="language-bash">gatk CombineGVCFs \
  -R reference.fasta \
  --variant sample1.g.vcf.gz \
  --variant sample2.g.vcf.gz \
  -O cohort.g.vcf.gz

# 将染色体拆分运行
gatk --java-options &quot;-Xmx4g -Xms4g&quot; CombineGVCFs -L 1 -V DRR083661.g.vcf.gz -O chr1.vcf.gz -R /home/chphl/2022_3_4_WGS/00.ref/arab_ref.fa
</code></pre>
<p>官方说明文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360037593911-CombineGVCFs</p>
<h3 id="gatkgenotypegvcfs">GATK：GenotypeGVCFs</h3>
<p>这边有一个非常关键词，“joint genotyping”。</p>
<p>genotyping，<strong>实际上就是发现给定群体（数据）中的DNA变异</strong>，包括SNP、INDEL、non-variation位点等。</p>
<ul>
<li>要求的输入数据是HaplotypeCaller附加“-ERC GVCF”或“-ERC BP_RESOLUTION”参数，所产生的gvcf文件</li>
<li>输出文件：VCF</li>
</ul>
<h4 id="genotypegvcfs示例代码">GenotypeGVCFs：示例代码</h4>
<pre><code class="language-bash">gatk --java-options &quot;-Xmx4g&quot; GenotypeGVCFs \
  -R Homo_sapiens_assembly38.fasta \
  -V input.g.vcf.gz \
  -O output.vcf.gz

# 当使用GenomicsDBImport作为合并HaplotypeCaller输出数据的工具时，
gatk GenotypeGVCFs \
    -R data/ref/ref.fasta \
    -V gendb://my_database \
    -O test_output.vcf
</code></pre>
<p>一些常用参数：</p>
<pre><code class="language-bash">--TMP_DIR                  # 使用暂时文件夹对结果文件进行保存
--max-genotype-count       # 每一个位置的genotype数量上限，默认为1024

# 其他参数
--sample-ploidy            # 在混池测序的时候需要注意，设置为“Number of samples in each pool * Sample Ploidy”
</code></pre>
<p>官方说明文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360037057852-GenotypeGVCFs</p>
<p>[2] https://gatk.broadinstitute.org/hc/en-us/articles/360035889971--How-to-Consolidate-GVCFs-for-joint-calling-with-GenotypeGVCFs</p>
<h3 id="gatkselectvariants">GATK：SelectVariants</h3>
<p>SelectVariants用于选择给定VCF文件中的个体 &amp; SNP类型（Select a subset of variants from a VCF file），功能可以概述为：</p>
<p>1、从给定VCF文件中，挑选个体（参数：-sn）</p>
<p>2、从给定VCF文件中，挑选对应区域（参数：--intervals）</p>
<p>3、选择不同类型的SNP（参数：--select-type）</p>
<p>e.g. 只挑选“INDELs”</p>
<p>一些常用参数：</p>
<pre><code class="language-bash">-R | --reference           # 给定参考基因组（官网说明文档给的是NULL，可有有无？）
--sn                       # 选择给定的样本，样本名保存在以.args结尾的文本中（一定要.args结尾！！！）
-xl-sn                     # 反向选择样本
--intervals                # 选择给定区域
--select-type-to-include | -select-type   # 选择保留给定类型的一种variants（注意，只有一种）
                                          # 没有给定的情况下，默认保留所有位点
                                          # ！！！多次设置来选择多种类型的位点
# 包括：INDEL, SNP, MIXED, MNP, SYMBOLIC, NO_VARIATION
# INDEL：insertion和deletion
# SNP：single nucleotide polymorphism
# MIXED：同一个位置上，不仅有SNP，还有IDEL（在多个个体水平）
# MNP：由相邻物理位置上组合成的SNP集合
# SYMBOLIC：
# NO_VARIATION：非多态性位点
 
--restrict-alleles-to        # 限制variants的类型为“ALL”，“BIALLELIC”，“MULTIALLELIC”其中的一种
--exclude-filtered           # 启用该FLAG值时，输出结果中只会包括有“PASS”标记的位点
--set-filtered-gt-to-nocall  # 默认情况下不开启，开启之后将“./.”位点全部过滤
</code></pre>
<p>其他参数：</p>
<pre><code class="language-bash">--selectExpressions     # 选择variants的标准（自行定义）
</code></pre>
<h4 id="需要注意的问题indexfeaturefile">需要注意的问题：IndexFeatureFile</h4>
<ul>
<li>在服务器中移动VCF文件时，转移到一个文件夹的时候忘记把对应VCF文件的<strong>索引</strong>也转移过来了</li>
<li>或者，本身就没有对该VCF创建索引</li>
</ul>
<p>可以使用如下命令，对目标VCF文件建立索引</p>
<pre><code class="language-bash">gatk --java-options &quot;-Xmx4G&quot; IndexFeatureFile --input input.vcf
</code></pre>
<h4 id="需要注意的问题createsequencedictionary">需要注意的问题：CreateSequenceDictionary</h4>
<p>在输入参考基因组（fasta格式）进行辅助分析的时候，不仅需要使用samtools对fasta文件进行fai索引的构建，还需要使用属于Picard工具包的CreateSequenceDictionary对其进行dict文件的构建：</p>
<pre><code class="language-bash">samtools faidx ref.fasta
# 结果文件：ref.fasta.fai

gatk CreateSequenceDictionary R=ref.fasta O=ref.dict
# 结果文件：ref.dict
</code></pre>
<p>官方说明文档：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360036362532-SelectVariants</p>
<p>[2] https://gatk.broadinstitute.org/hc/en-us/articles/360035530752-What-types-of-variants-can-GATK-tools-detect-or-handle-</p>
<p>[3] https://gatk.broadinstitute.org/hc/en-us/articles/360035890771-Biallelic-vs-Multiallelic-sites</p>
<p>[4] https://www.strand-ngs.com/files/manual/reference/snp.html</p>
<h3 id="gatkvariantfiltration">GATK：VariantFiltration</h3>
<p>VariantFiltration命令主要的功能是设置阈值，对SNP进行硬过滤，在FILTER这一列对位点进行标记。</p>
<ul>
<li>一般被过滤的位点，被标记为自行给定的FILTER名称</li>
<li>没有被过滤的位点，被标记为PASS</li>
</ul>
<h4 id="variantfiltration示例代码">VariantFiltration：示例代码</h4>
<pre><code class="language-bash">gatk VariantFiltration \
-R reference.fasta \
-V input.vcf.gz \
-O output.vcf.gz \
--filter-name &quot;my_filter1&quot; \
--filter-expression &quot;AB &lt; 0.2&quot; \
--filter-name &quot;my_filter2&quot; \
--filter-expression &quot;MQ0 &gt; 50&quot;
</code></pre>
<h4 id="一些参数的说明">一些参数的说明</h4>
<p>官方推荐将SNP和INDEL单独提取出来之后，再分别进行VariantFiltration。</p>
<p>【分析标注】SelectVariants使用“-select-type”对变异位点进行筛选时，只会根据给定类型，筛选单一子集（e.g. 给定选择SNP，就只会筛选SNP，不会选择SNP和INDEL共存的位点）。若需要选择混合类型的位点，使用参数“MIXED”</p>
<pre><code class="language-bash"># 示例hard-filtering
gatk VariantFiltration \
    -V snps.vcf.gz \
    -filter &quot;QD &lt; 2.0&quot; --filter-name &quot;QD2&quot; \
    -filter &quot;QUAL &lt; 30.0&quot; --filter-name &quot;QUAL30&quot; \
    -filter &quot;SOR &gt; 3.0&quot; --filter-name &quot;SOR3&quot; \
    -filter &quot;FS &gt; 60.0&quot; --filter-name &quot;FS60&quot; \
    -filter &quot;MQ &lt; 40.0&quot; --filter-name &quot;MQ40&quot; \
    -filter &quot;MQRankSum &lt; -12.5&quot; --filter-name &quot;MQRankSum-12.5&quot; \
    -filter &quot;ReadPosRankSum &lt; -8.0&quot; --filter-name &quot;ReadPosRankSum-8&quot; \
    -O snps_filtered.vcf.gz
gatk VariantFiltration \ 
    -V indels.vcf.gz \ 
    -filter &quot;QD &lt; 2.0&quot; --filter-name &quot;QD2&quot; \
    -filter &quot;QUAL &lt; 30.0&quot; --filter-name &quot;QUAL30&quot; \
    -filter &quot;FS &gt; 200.0&quot; --filter-name &quot;FS200&quot; \
    -filter &quot;ReadPosRankSum &lt; -20.0&quot; --filter-name &quot;ReadPosRankSum-20&quot; \ 
    -O indels_filtered.vcf.gz
</code></pre>
<p>再给出一篇文章中的过滤参数：</p>
<figure data-type="image" tabindex="1"><img src="https://Youpu-Chen.github.io//post-images/1660188613462.png" alt="" loading="lazy"></figure>
<p>官方说明文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360037434691-VariantFiltration</p>
<p>[2] https://gatk.broadinstitute.org/hc/en-us/articles/360035531112--How-to-Filter-variants-either-with-VQSR-or-by-hard-filtering【主要看“2. Hard filter a cohort callset with VariantFiltration”这部分就行】</p>
<h2 id="其他gatk命令">其他GATK命令</h2>
<h3 id="gatk碱基质量矫正">GATK：碱基质量矫正</h3>
<p>碱基质量矫正（Base Quality Score Recalibration/BQSR），这一步分析主要用于检测由于测序仪器造成的系统误差。</p>
<h4 id="bqsr理解">BQSR理解</h4>
<p>可以从以下2个方面对BQSR进行理解：</p>
<p>1、首先需要明确的一点是，BQSR是对碱基质量值进行矫正，而不是碱基。碱基质量值代表了该碱基的可信度（有百分之多少的概率，我们可以相信这个位点的测序情况是正确的，或者说有百分之多少的概率，认为这个位点是测错的），而base quality又与后续的SNP检测有关，因此对碱基质量值进行矫正非常关键。</p>
<p>【标注】也就是说，我们不能够决定一个低质量的A碱基，其原本是不是一个T，但是我们可以决定相信这个A的程度（基于base quality）</p>
<p>2、BQSR通过机器学习的方法对base quality进行矫正（本质都是<strong>回归</strong>）</p>
<p>【标注】</p>
<ul>
<li>作者给出的例子，当AA在序列中连着出现的时候，认为后续出现的碱基都增加了1%被测序的概率，因此对应的base quality也需要下降</li>
<li>上述影响是具有累加性的</li>
</ul>
<h4 id="bqsr分析过程">BQSR分析过程</h4>
<p>1、基于输入数据（bam），建立一个<strong>协变模型</strong>（这个名词有待商榷）</p>
<p>结果文件为一个recalibration file</p>
<p>2、使用ApplyBQSR对原始输入文件的base quality进行矫正，结果文件为bam文件（新生成），同时在上述步骤要求输入先验SNP位点。具体过程：</p>
<ul>
<li>统计全局差异（observed/reported quality vs expected/empirical quality）</li>
<li>每一个位点加上窗口计算的差异 + 每一个位点加上循环计算 &amp; dinucleotide差异</li>
</ul>
<p>【分析标注】</p>
<ul>
<li>“dinucleotide”【待解决】</li>
<li>推荐二次建立模型，看看recalibration对整体结果的影响变化。</li>
</ul>
<h4 id="bqsr示例代码">BQSR：示例代码</h4>
<pre><code class="language-bash"># 还没学，用不到
</code></pre>
<p>官方文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360035890531-Base-Quality-Score-Recalibration-BQSR-</p>
<p>[2] https://gatk.broadinstitute.org/hc/en-us/articles/360036898312-BaseRecalibrator</p>
<h3 id="gatkvariantrecalibrator-applyvqsr">GATK：VariantRecalibrator &amp; ApplyVQSR</h3>
<p>VariantRecalibrator采用机器学习的方式，计算位点的VQSLOD值（取代该位点原本的QUAL），作为后续分析的指标，一般分为以下2个步骤：</p>
<ul>
<li>使用高质量的VCF数据集，训练模型</li>
<li>将模型应用到我们自己的数据当中去</li>
</ul>
<p>从上述的话，其实也能很明显地看出来，VariantRecalibrator &amp; ApplyVQSR这套方法的缺陷 —— 需要先验的高质量VCF数据集。</p>
<p>输入数据的要求：</p>
<figure data-type="image" tabindex="2"><img src="https://Youpu-Chen.github.io//post-images/1660188666242.png" alt="" loading="lazy"></figure>
<h4 id="variantrecalibrator示例运行">VariantRecalibrator：示例运行</h4>
<pre><code class="language-bash"># exome data
gatk VariantRecalibrator \
  -R Homo_sapiens_assembly38.fasta \
  -V input.vcf.gz \
  --resource hapmap,known=false,training=true,truth=true,prior=15.0:hapmap_3.3.hg38.sites.vcf.gz \
  --resource omni,known=false,training=true,truth=false,prior=12.0:1000G_omni2.5.hg38.sites.vcf.gz \
  --resource 1000G,known=false,training=true,truth=false,prior=10.0:1000G_phase1.snps.high_confidence.hg38.vcf.gz \
  --resource dbsnp,known=true,training=false,truth=false,prior=2.0:Homo_sapiens_assembly38.dbsnp138.vcf.gz \
  -an QD -an MQ -an MQRankSum -an ReadPosRankSum -an FS -an SOR \
  -mode SNP \
  -O output.recal \
  --tranches-file output.tranches \
  --rscript-file output.plots.R
  
# Allele-specific version of the SNP recalibration
gatk VariantRecalibrator \
  -R Homo_sapiens_assembly38.fasta \
  -V input.vcf.gz \
  -AS \
  --resource hapmap,known=false,training=true,truth=true,prior=15.0:hapmap_3.3.hg38.sites.vcf.gz \
  --resource omni,known=false,training=true,truth=false,prior=12.0:1000G_omni2.5.hg38.sites.vcf.gz \
  --resource 1000G,known=false,training=true,truth=false,prior=10.0:1000G_phase1.snps.high_confidence.hg38.vcf.gz \
  --resource dbsnp,known=true,training=false,truth=false,prior=2.0:Homo_sapiens_assembly38.dbsnp138.vcf.gz \
  -an QD -an MQ -an MQRankSum -an ReadPosRankSum -an FS -an SOR \
  -mode SNP \
  -O output.AS.recal \
  --tranches-file output.AS.tranches \
  --rscript-file output.plots.AS.R
</code></pre>
<p>官方说明文档如下：</p>
<p>[1] https://gatk.broadinstitute.org/hc/en-us/articles/360036510892-VariantRecalibrator</p>
<p>[2] https://gatk.broadinstitute.org/hc/en-us/articles/360035535932-Germline-short-variant-discovery-SNPs-Indels-</p>
<h3 id="gatkmergevcfs">GATK：MergeVCFs</h3>
<p>MergeVCFs是包含在Picard内的一个工具，用于合并不同区域的VCF文件</p>
<p>对输入文件的要求如下：</p>
<ul>
<li>每个VCF文件所包含的sample要一致</li>
<li>Input file headers must be contain compatible declarations for common annotations (INFO, FORMAT fields) and filters，即一些通用信息要包含（e.g. INFO, FORMAT, filters）</li>
<li>每个VCF文件包含的SNP，要求经过排序</li>
</ul>
<h4 id="mergevcfs示例代码">MergeVCFs：示例代码</h4>
<pre><code class="language-bash">java -jar /path/picard.jar MergeVcfs \
          I=input_variants.01.vcf \
          I=input_variants.02.vcf.gz \
          O=output_variants.vcf.gz
</code></pre>
<h2 id="题外话">题外话</h2>
<h3 id="gatk什么是read-group-如何添加read-group信息">GATK：什么是read group &amp; 如何添加read group信息</h3>
<p>在进行bwa mem比对时，需要向bam/sam文件中，添加read group信息。</p>
<p>如果bam/sam文件中，没有对应信息，则会报错。</p>
<h4 id="1gatk需要的read-group信息是什么">（1）GATK需要的read group信息是什么？</h4>
<pre><code class="language-bash">ID = Read group identifier
# 每一个read group 独有的ID，每一对reads 均有一个独特的ID，可以自定义命名；

PL = Platform
# 测序平台：ILLUMINA, SOLID, LS454, HELICOS and PACBIO，不区分大小写；

SM = sample
# reads属于的样品名；SM要设定正确，因为GATK产生的VCF文件也使用这个名字;

LB = DNA preparation library identifier
# 对一个read group的reads进行重复序列标记时，需要使用LB来区分reads来自那条lane;有时候，同一个库可能在不同的lane上完成测序;为了加以区分，
# 同一个或不同库只要是在不同的lane产生的reads都要单独给一个ID. 一般无特殊说明，成对儿read属于同一库，可自定义，比如：library1
</code></pre>
<h4 id="2如何进行read-group信息添加">（2）如何进行read group信息添加？</h4>
<p>图示：<br>
<img src="https://Youpu-Chen.github.io//post-images/1660299121752.png" alt="" loading="lazy"></p>
<pre><code class="language-bash">@A00312:194:HFK5KDSX2  # 测序仪器
4                      # lane ID
1101                   # tail坐标
24469                  # tail x坐标
13150                  # tail y坐标
# bwa比对时，对read group信息进行添加
bwa -R '@RG\tID:lane_${lane}\tPL:illumina\tSM:${sample}'
</code></pre>
<p>参考资料如下：</p>
<p>https://www.jianshu.com/p/c41e8f3266b4</p>
<h2 id="写在最后">写在最后</h2>
<p>变异分析流程的软件有很多，金标准只有GATK一个（针对于WGS和WES），但是GATK自己本身就不断在更新。所以说，只学习别人软件的用法，这样还是走不长远的，我觉得还是需要以后自己有能力去做一款软件，靠这个吃饭，我觉得比较ok。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「Hello Gridea」Here comes Youpu-Chen]]></title>
        <id>https://Youpu-Chen.github.io/post/hello-gridea/</id>
        <link href="https://Youpu-Chen.github.io/post/hello-gridea/">
        </link>
        <updated>2022-08-09T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>这是从Gridea开始的第一篇故事。</p>
<p>2022年的暑假事情也很多，</p>
<p>之前租了个服务器，使用Halo搭建自己的个人博客，经营了一段时间，也使用过hexo，</p>
<p>但是hexo对于当初的我，我花了三天才将它搭建起来。</p>
<p>最近又发现一款很不错的搭建博客工具 —— Gridea。</p>
<p>根据我自己的个人使用经验，</p>
<ul>
<li>hexo，对我来说就像一台老爷车，打开车盖，结构精美，但是也非常繁杂</li>
<li>Halo，就像一台重装坦克</li>
<li>Gridea，就像一台超跑</li>
</ul>
<p>那像我这样放荡不羁爱自由的人，当然就选择Gridea了。</p>
<h1 id="gridea客户端安装">「Gridea」客户端安装</h1>
<p>官网 -&gt; <a href="https://gridea.dev/">Click here</a></p>
<p>0）根据自己的系统选择即可<br>
<img src="https://Youpu-Chen.github.io//post-images/1660115082807.png" alt="" loading="lazy"></p>
<h1 id="gridea与github">「Gridea与Github」</h1>
<p>1）首先，需要有一个Github账号<br>
2）创建一个名字为<code>&lt;username&gt;.github.io</code>的仓库<br>
3）Gridea远程配置如下即可，<br>
<img src="https://Youpu-Chen.github.io//post-images/1660114907888.png" alt="" loading="lazy"></p>
<h2 id="如何绑定自己的域名">如何绑定自己的域名？</h2>
<p>以腾讯云为例，在控制台完成如下操作即可 -&gt; A &amp; CNAME的配置，<br>
<img src="https://Youpu-Chen.github.io//post-images/1660114916595.png" alt="" loading="lazy"></p>
<p>在Github创建的仓库中，输入域名即可<br>
「记得<code>Enforce https</code>」<br>
<img src="https://Youpu-Chen.github.io//post-images/1660114927770.png" alt="" loading="lazy"></p>
<h1 id="gridea主题更换">「Gridea」主题更换</h1>
<p>以gridea-theme-one为例，Github链接 -&gt; <a href="https://github.com/kytrun/gridea-theme-one.git">one</a></p>
<p>「克隆仓库前，记得想想自己将Gridea的工作目录放置到了哪里，」</p>
<p>1）克隆到本地</p>
<pre><code class="language-shell">git clone https://github.91chi.fun/https://github.com/kytrun/gridea-theme-one.git one
</code></pre>
<p>2）重启Gridea客户端，选择<code>One</code>即可</p>
<h1 id="小记">小记</h1>
<p>整个安装过程中，还是出现了一些问题，因为我需要与原本的Halo接触绑定、解析新的链接、处理SSL证书过期的事情……</p>
<p>Take it slow, the clock is not ticking.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「我的大学，是怎么样的？」]]></title>
        <id>https://Youpu-Chen.github.io/post/aboutuniversity/</id>
        <link href="https://Youpu-Chen.github.io/post/aboutuniversity/">
        </link>
        <updated>2021-10-03T01:46:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="part1-校园回忆录">Part1-校园回忆录</h2>
<p>一提起大学，你最先想起关于它的事情是什么？闭上眼睛想一想。</p>
<p><strong>大一</strong>：“学习，学了十二年了，有什么好学的，爷要放松，爷要撒野，芜湖！我今天学习不好我以后照样能找到好的工作”<br>
​<strong>大二</strong>：“已经挂了科了，这有啥的。我现在不是照样如鱼得水？哎呦，今天出了新皮肤？买。喜欢的游戏又降价了！冲。”……</p>
<p>最后到了大三，看着自己不如意的成绩，看着周围都在努力学习的同学：<br>
“哇，ta好厉害啊，都保研了，什么清华啊！啊，ta还去了北大！？”<br>
“大家都好努力的学习，我是不是也要开始学习了呢？”</p>
<p>但是合上眼，回想起自己三年之间的生活，当大家都在图书馆努力学习的时候，自己躺在宿舍的床上，看着电视剧，打着游戏，吹着空调，看着窗外熙熙攘攘的人群，心想“真热，这群人都是傻子吗，有空调不吹，跑到外头去干啥？还是躺在宿舍舒服”。当大家已经确定未来努力方向的时候（无论是工作、考研或者是创业，只要自己有想法就是好的），自己也逐渐开始焦虑起来：</p>
<p>“我该怎么办？要不要去图书馆学习？”<br>
​“要不要去实验室打工啊，感觉好累的。。”<br>
​“有同学找我做大创啊，我要不要去参与呢？还有好多好多比赛，我要不要试试呢？”</p>
<p>但是又转念一想：</p>
<p>“去图书馆的路上好热啊，去了还不一定有位置还是不去了。”<br>
​“实验室，我有不搞科研，实验室有啥好去的，没意思”<br>
​  “大创。。要写计划书，要看文献，真麻烦，打开电脑我都觉得麻烦。。”</p>
<p>最后你放弃了思考，像天上的卡兹一样停止了思考（此处为jojo梗），觉得思考太费力气，还是保持现状比较好。<br>
<img src="https://Youpu-Chen.github.io//post-images/1660442578922.png" alt="" loading="lazy"></p>
<p>再过了几年，你发现自己混的不如意，只能回老家考一个公务员，又或者在一个小公司上班遇到了黑心的老板，每天压榨员工，自己生活仿佛乌云笼罩，窗外的太阳很大，只是透不进来。</p>
<p><strong>就此打住，我希望你对自己大学生活的回忆不是这样</strong></p>
<p>我希望你对大学生活的回忆是这样的：</p>
<p><strong>大一</strong>：“哇，自己高考考的还不错，来了一所自己觉得不错的大学，选的这所大学里的同学都好优秀啊，我也要好好学习，把自己变优秀才可以”<br>
<strong>大二</strong>：“有一定的专业基础了，是不是可以开始将理论运用于实践了呢？该去尝试哪个方向呢？都试试吧，毕竟年轻人，就是要敢于试错，多尝试一些新鲜东西，多学一点东西，总没错的”<br>
<strong>大三</strong>：<br>
​“为了弥补一下自己高中没有考上自己理想大学的遗憾，我决定了！我要去这里”<br>
“这家公司的实习机会非常宝贵，我觉得我应该利用大三暑假提升自己的实习经历，这样我毕业之后才能找到一份自己理想的工作！”</p>
<p>再过了几年，你发现自己硕士毕业了 或者 在职场中打拼几年了：</p>
<p>“我想要继续深造，这所课题组/大学/科研机构）的研究方向我很感兴趣，我决定要申请这里的博士”<br>
“这份工作，我觉得对我来说已经没有挑战性了，也没有太大的上升空间，我决定要向下一个岗位进发”</p>
<h2 id="part2-回答what-is-university">Part2-回答“What is University?”</h2>
<p><img src="https://Youpu-Chen.github.io//post-images/1660442593831.png" alt="" loading="lazy"><br>
大学是什么？我个人觉得理想中的大学应该是充满了各种天马行空想法和热情的地方，每个人都能在自己所选定的方向上发光发热。但是我知道这是不现实的，这个时代是不断在前进没有错，但是我们没有必要要求所有人都前仆后继地投身到“伟大事业建设”中去。</p>
<p>如果你很早就确定了自己未来想从事的工作，明确了自己前进的方向，对自己的“工作”和生活充满了热情，那么祝贺你，你已经走在了大部分人的前面。但是，如果你还没有，“keep looking, don't settle”<br>
<img src="https://Youpu-Chen.github.io//post-images/1660442601337.png" alt="" loading="lazy"></p>
<center>上图截自Steve Jobs 2005年在Standford University的毕业典礼演讲​</center>
<p>大部分的人，都很难在高中阶段（甚至进入社会后的几十年是，这是现实情况）找到自己真正热爱的是什么，因此大学提供了一个非常好的机会给我们去探索，去勇敢地尝试（年轻人，就是要勇于试错！年轻的时候试错成本低），在这个探索过程中，我们说不定就能发现我们真正热爱的事情是什么（但是关于热爱和兴趣这件事，有兴趣的同学可以找我私聊，目前博客没有设置评论功能）。</p>
<p><strong>不要被自己的专业所局限住</strong>，因为高中选专业的时候可能有父母在旁边左右（我没有，我自己作死来的福州 <strong>😃</strong> ），可能还是一个懵懂的高中生凭着感觉选择的专业。所以，在进入大学之后，我个人推荐推荐你可以动动自己的小指头，打开咱们学校的教务系统，看看其他专业上的课有没有自己感兴趣的，可以去听听看。同时，现在已经是互联网时代了，要利用好网络上的资源，“好的大学没有围墙”（我觉得我在本科期间，在实验室内，我真正锻炼到的是我的自学能力。在此包含辛酸泪地说一句，“羡慕那些刚进实验室就有人带的孩子，这样起步比我快多了”）。</p>
<p>在这边可能还要说一个郭老师当年传授的例子（非常冷）：</p>
<p>郭老师：“同学你想学计算机，你说你去看农大的课还是看厦大的课？”<br>
​我：“厦大（秒答，认真脸）”<br>
​郭老师：“你傻啊，你当然是去看哈佛的课啊！”</p>
<p>在你选定好要去做什么之后，你一定要拿出自己的行动力/执行力，只有当你成为一个“practical idealist”，你才能够将自己非常优秀的idea变成你想要的结果（这边开个小小的玩笑，如果有幸看到这篇文章的你在十几年之后成为了课题组组长或者boss，你才能够自己不行动，让手下帮你实现）。还有一个原因，就是大学四年的时间实在是有限，一定要懂得珍惜当下，要“seize the day/carpe diem”（啥都要趁早，谈恋爱也是。这里可以这样理解，高中就谈过恋爱的人，ta们有了去爱别人的能力，相较于没有谈过恋爱的人来说，而能够去爱别人是一种非常重要的能力）</p>
<p>下面我想给还在努力奋斗的同学提一些建议（我也在奋斗，学习是一辈子的事）：</p>
<ul>
<li>不要将实验室的学习，看作一个太过功利的过程，要注重自己在实验室学到了什么，而不是单纯为了科研发文章、做项目加分去实验室，自己的能力得到了锻炼才是最重要的</li>
<li>不要为了保研而保研（恶性竞争不好，同时会让你忽视自己的兴趣，“narrow and constraint your own thoughts”）</li>
<li>不要只是为了简历好看而去当班委</li>
</ul>
<h2 id="题外话好老师的定义是什么">题外话：好老师的定义是什么？</h2>
<p>PS：Harvard positive psychology中提到了一位非常厉害的老师 —— Marva Collins（她的事迹，有兴趣的同学可以上百度搜搜）。</p>
<p>我在本科的学习生活中认识了非常多的老师，有资历高的教授，有刚进学校的青椒，有人生导师（重点描述对象），当然也有让我觉得disgusting的老师（这可能是现存制度的问题）。</p>
<p>实话实说，刚进大一的我，整天看到创新班英语群里在发“加油加油加油”的表情包，我以为我加入了什么邪教组织，每次看到同学们在里面发啥标语，我笑得比看“你得支棱起来啊”笑的还欢，有一种众人皆醉我独醒的感觉，如下：<br>
<img src="https://Youpu-Chen.github.io//post-images/1660442610790.png" alt="" loading="lazy"></p>
<p>到后来，我发现我错了，我错得很彻底。当大一下学期郭老师给我们正式上课的时候，又或者说当雅思培训开始时，我真正意识到这个男人配得上“我愿称你为最强”（不好意思，我有中二病，可能治不好的那种哈哈哈哈）。</p>
<p>郭老师的冰山理论、ppp理论，说实话，忘了很多了，但是当我每每想起雅思培训时老郭说的一些话，我总是会有一种不可言喻的感觉。郭老师看到了我的闪光点，或许是连我自己都没有看到的闪光点，并将它轻轻一推，但就是这轻轻一推，让原本只是宇宙中一颗小小尘埃，变成了能够照亮整个太阳系的光源：</p>
<p>“你这么努力，我觉得你有可能是在坐的同学里面，有机会去面试浙大的学生，但是学习不仅要work hard，还要work smart……”</p>
<p><strong>与郭老师畅聊半小时，可能算的上是我那个暑假收获最大的一件事</strong>。</p>
<p>走到如今这一步之前，我也没有想到我能一步迈上这么高的台阶，这过程中充满了很多外界的怀疑和自己本身的猜忌。虽然我知道，郭老师可能对每一位进去的同学都说了“你能够去挑战浙大”这样的话，但是我最终选择相信我自己（但是不可否认的是，运气有时候是很重要的）。</p>
<center>“当别人都说你不行的时候，你要相信你自己行，因为如果你自己都不相信自己了，谁去相信你”</center>
<p>很感谢郭老师在我非常质疑自己的时候，给了我一剂强心剂，但让这药效在我内心渗透开的是我后续不断的努力。也非常感谢郭老师，给了当时我原本已经没有机会培训雅思的我一次机会（PS: 班委一定要记得处理好班上的信息，不要摆架子。。），在那短短的42天里，学习的不仅仅是英语，更是其他更重要的东西。</p>
<h2 id="题外话关于焦虑">题外话：关于焦虑</h2>
<p>大二，看着周围的同学要么就是在实验室已经混的风生水起，而我还是一个“三无”人员，我感觉到非常焦虑：</p>
<p>“完了完了，这还咋整啊”，当时的心情简直如《Catch My Breath》中的歌词“<em>I don't wanna be left behind</em>”一样。在再三的犹豫下，被老何画饼画进了实验室。</p>
<p>一开始，老何说：</p>
<p>“Oh，我亲爱的学生，我这边有一个假说，你去查文献收集数据，看看能不能做出点东西来，最好的结果可能是SCI二区呢~”</p>
<p>于是，我开启了全在查文献的大二上学期。在这种工作状态下，这个学期很快，一下就来到了末尾，但其实我是对这个项目不是很感兴趣，所以坚持了一个学期我也肝不动了。理所当然的，当那场突如其来的疫情来的时候，我可以肆无忌惮地放下了手中的工作，每天睡到上课前5分钟才醒，上课可以更容易地开小差了，晚上可以什么事情都不管，去和同学们打游戏了，可以随意熬夜了。这是我想象中的大学生活吗？不是，这完全不同，热情和追求在慢慢地流失，在4月份就失去了对所有事情的兴趣。walking dead用在当时的我身上再恰当不过了。</p>
<p>但或许是期末考的来临和大三学年来临的压迫感，把我从逃避的情绪中拉回来，在大二的暑假闭关学习。充分利用网络上的资源，学习当时觉得非常有趣的学科——“生物信息学”。一开学，老何看我怎么突然“啥都会了”，就开始叫我干活，我也真正投入了实验室的科研工作（并不是说之前的查文献都不算科研，运用meta分析，处理数据、整合结果，这都是科研的一部分，只不过在当时我对这部分工作并不感兴趣）。</p>
<p>但是当我真正投入的时候，焦虑感也始终是存在的，因为周围大部分的人都有了成果，我还是个fresh man，心中自然是少不了焦虑的。但是我始终认为的是“学到东西，比当混子有用得多”，所以在一次又一次周围同学一步登天时，我开始真正关注于自己手头上的工作，对自己做的课题也越来越深入和了解。但是真正让我感到不焦虑时候，还就是复试的时候，准备得足够充分，对自己的课题的了解、英语的表达以及对科研的兴趣，我觉得都是我最后能够拿到offer的原因。</p>
<p>所以最后总结下来，消除焦虑的方法就是走出自己的节奏，进入自己的状态，每天该完成事情都完成，该休息的时候休息。</p>
<center>“小时候，大人往往说重要的是过程，结果只是过程的副产物” —— 排球少年</center>
<p>当自己去努力的时候，人的内心都是希望得到一个自己预期的结果的，但是有时候结果往往不仅由自己的努力程度所决定，外界因素也非常重要，这给结果蒙上了一层不确定因素的面纱。所以，在一个短期内，结果没有达到自己的预期，没关系，只要你认定了一个目标，花上五年十年的时间，去实现它，我觉得都是非常意义的，毕竟有时候绕最远的路才是捷径。</p>
]]></content>
    </entry>
</feed>